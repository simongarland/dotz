<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb">
<head>

  <style type="text/css">
/*<![CDATA[*/
BODY {
	FONT-FAMILY: cambria,palatino, palatino linotype, georgia, serif;
}
CODE {
FONT: consolas,"andale mono", monaco, courier, "courier new", monospace; COLOR: #06c
}
a {
color: dodgerblue;}
a:link, a:visited {
text-decoration: none;}
a:hover {
border-bottom: dashed 1px dodgerblue;}
#container {
width: 760px;
border: 1px solid #024C7E ;
margin: 10px;
margin-left: auto;
margin-right: auto;
padding: 10px;
}
#banner {
padding: 5px;
margin-bottom: 5px;
color: white ;
background-color: black ;
font-size: x-large ;
}
#content {
padding: 5px;
background-color: white ;
}
#footer {
clear: both;
padding: 5px;
margin-top: 5px;
font-size:x-small ;
background-color: white;
}
/*]]>*/
  </style>
  <title>custom .z.p* for kdb+ sessions</title>
</head>
<body>
<div id="container">
<div id="banner">
<p>custom .z.p* for kdb+ sessions </p>
</div>
<div id="content"> <a name="#top"></a>
<h2>overview</h2>
<p>a set of self-contained utilities for monitoring and controlling access to a kdb+ task. Download the latest version from <a href="http://271828.net/download/dotz.zip" title="dotz.zip">271828.net</a></p>
<p>all of them work by wrapping the .z.p* entry points for remote calls. </p>
<p>multiple files can be combined but the revert function just cuts right back to initial setup.</p>
<h2>monitoring usage </h2>
<h3>dumpusage.q</h3>
<p>dump remote accesses to a kdb+ session directly to the console using 0N!. This is most useful as a barebones example of how to write your own version.</p>
<h4>sample output:</h4>
<code>q)832<br />
832<br />
"2+2 3 2"<br />
4 5 4<br />
"2 2+2 3 2"<br />
'length<br />
@<br />
.:<br />
"2 2+2 3 2"<br />
"key 11"<br />
0 1 2 3 4 5 6 7 8 9 10<br />
"reverse key 5"<br />
4 3 2 1 0<br />
832<br />
832</code>
<p>undo/remove the logging by running .usage.revert[].</p>
<h3>lastusage.q</h3>
<p>like dumpusage, but just saves the last command and parameters to locale .last, convenient for quick debugging as you have the actual data</p>
<p>undo/remove the logging by running .usage.revert[].</p>
<h3>traceusage.q</h3>
<p>like dumpusage, but displays a formatted trace of remote accesses in the console.</p>
<h4>sample output:</h4>
<code>2005.11.11 16:38:43.078 0ms pg a:127.0.0.1 u:simon w:832
2+2 3 2<br />
*2005.11.11 16:38:43.078 (error:length) ps a:127.0.0.1 u:simon w:832 2
2+2 3 2<br />
'length<br />
2005.11.11 16:38:43.078 0ms pg a:127.0.0.1 u:simon w:832 key 11<br />
2005.11.11 16:38:43.078 0ms pg a:127.0.0.1 u:simon w:832 reverse key 5<br />
2005.11.11 16:38:43.078 0ms pc a:10.0.0.8 u:simon w:0 832<br />
2005.11.11 16:38:43.141 0ms ph a:127.0.0.1 u: w:832<br />
2005.11.11 16:38:43.219 0ms ph a:127.0.0.1 u: w:832 ?2+2<br />
*2005.11.11 16:38:43.297 (error:notfound) ph a:127.0.0.1 u: w:832
?notfound</code>
<p>undo/remove the logging by running .usage.revert[].</p>
<h3>monitorusage.q</h3>
<p>same format as traceusage but saves output to session table USAGE rather than dumping direct to console. More convenient if you want to analyse the data rather than just displaying it.</p>
<h4>sample output:</h4>
<code>q)show USAGE<br />
date time ms zcmd ipa u w cmd ok error<br />
-----------------------------------------------------------------------------<br />
2005.11.11 16:41:10.062 0 po 127.0.0.1 simon 832 832 1<br />
2005.11.11 16:41:10.062 0 pg 127.0.0.1 simon 832 2+2 3 2 1 <br />
2005.11.11 16:41:10.062 0 ps 127.0.0.1 simon 832 2 2+2 3 2 0 length<br />
2005.11.11 16:41:10.062 0 pg 127.0.0.1 simon 832 key 11 1<br />
2005.11.11 16:41:10.062 0 pg 127.0.0.1 simon 832 reverse key 5 1<br />
2005.11.11 16:41:10.078 0 pc 10.0.0.8 simon 0 832 1<br />
2005.11.11 16:41:10.141 0 ph 127.0.0.1 832 1<br />
2005.11.11 16:41:10.234 0 ph 127.0.0.1 832 ?2+2 1<br />
2005.11.11 16:41:10.313 0 ph 127.0.0.1 832 ?notfound 0 notfound<br />
</code>
<p>undo/remove the logging by running .usage.revert[].</p>
<h3>logusage.q</h3>
<p>like monitorusage, but logs direct to a file (like the one used by kdb+tick) - so data survives beyond the current session. Load and display the contents of the log using loadusage.q (uses custom -11!)</p>
<p>if you want to use a non-standard file modify the variable .usage.FILE in file logusage.custom.q</p>
<h4>sample output:</h4>
<code>S:\&gt;q loadusage.q<br />
KDB+ 2.3t 2005.11.08 Copyright (C) 1993-2005 Kx Systems<br />
date time ms zcmd ipa u w cmd ok error<br />
-----------------------------------------------------------------------------<br />
2005.11.11 16:43:31.141 0 po 127.0.0.1 simon 828 828 1<br />
2005.11.11 16:43:31.141 0 pg 127.0.0.1 simon 828 2+2 3 2 1 <br />
2005.11.11 16:43:31.141 0 ps 127.0.0.1 simon 828 2 2+2 3 2 0 length<br />
2005.11.11 16:43:31.141 0 pg 127.0.0.1 simon 828 key 11 1<br />
2005.11.11 16:43:31.141 0 pg 127.0.0.1 simon 828 reverse key 5 1<br />
2005.11.11 16:43:31.141 0 pc 10.0.0.8 simon 0 828 1<br />
2005.11.11 16:43:31.188 0 ph 127.0.0.1 828 1<br />
2005.11.11 16:43:31.297 0 ph 127.0.0.1 828 ?2+2 1<br />
2005.11.11 16:43:31.375 0 ph 127.0.0.1 828 ?notfound 0 notfound<br />
2005.11.11 16:43:31.406 0 po 127.0.0.1 simon 828 828 1<br />
q)</code>
<p>undo/remove the logging by running .usage.revert[].</p>
<p>if you want loadusage.q to load and display a non-default file just give the name as a startup parameter.</p>
<p>All of the *usage utilities can have the level of information they log controlled by the LEVEL variable - 0 =&gt; no logging, 1 =&gt; only errors, 2 (default) =&gt; everything.</p>
<p>Note that all of this logging imposes an overhead - the one that gets in the way least is logusage</p>
<h2>tracking clients and servers </h2>
<h3>trackclients.q</h3>
<p>track clients with open handles to the session via .z.po and .z.pc, current status stored in table CLIENTS.</p>

<h4>api:</h4>
<dl>
  <dt>handle:.clients.add[handle]</dt>
  <dd>use this to manually add a client - usually they're added
via .z.po so you don't need to do anything</dd>
  <dt>handles:.clients.handles[]</dt>
  <dd>list all the active client handles</dd>
  <dt>.clients.leaky[]</dt>
  <dd>returns a table of all (potentially) leaky clients - those that have a whole pile of open handles and probably aren't cleaning them up correctly (this will only work if you're running the tracking in intrusive mode as it needs the remote port)</dd>
</dl>
<h4>sample session:</h4>
<code>S:\&gt;q trackclients.q -p 5001<br />
KDB+ 2.3t 2005.11.08 Copyright (C) 1993-2005 Kx Systems<br />
q)show CLIENTS<br />
w | ipa u a k K f pop poz<br />
---|------------------------------------------------------------------------<br />
832| 127.0.0.1 simon 2130706433 2005.11.08 2.3 5005
2005.11.11T16:47:03.156<br />
820| 127.0.0.1 simon 2130706433 2005.11.08 2.3 5005
2005.11.11T16:47:03.844<br />
808| 127.0.0.1 simon 2130706433 2005.11.08 2.3 5005
2005.11.11T16:47:04.453<br />
q) </code>
<p>pop is port on call of .z.po and poz is .z.z at call of .z.po.  When a client closes a handle the record is deleted.</p>
<p>undo/remove the tracking by running .usage.revert[].</p>
<p>by setting .clients.INTRUSIVE you can determine how intrusive the monitoring should be. If enabled clients are asked what version of k they're running, their OS and a few other things - if that's inappropriate then use the other version which just logs what it can get from the .z.po information (address and user).</p>
<p>clearly intrusive mode can only work with q clients</p>
<h3>trackservers.q</h3>
<p>track servers available to a kdb+ session, and provide utilities to maintain the list (in table SERVERS).</p>
<h4>api:</h4>
<dl>
  <dt>handle:.servers.add[name;hpup]</dt>
  <dd>add a new record for the server with name running at hpup</dd>
  <dt>handle:.servers.addp[name;hpup;private]</dt>
  <dd>like add, but sets the private flag (private servers aren't forwarded with grab)</dd>
  <dt>handles:.servers.handles[]</dt>
  <dd>return all available handles</dd>
  <dt>handles:.servers.close[handles]</dt>
  <dd>close the connections to the given handles and cleanup their SERVERS entries</dd>
  <dt>.servers.down[]</dt>
  <dd>list all servers which are currently down</dd>
  <dt>handle:.servers.handlefor[name]</dt>
  <dd>get a handle for the server running as name, if multiple
  instances exist the handles are roundrobin_ed (using lastz)</dd>
  <dt>.servers.grab[handle]</dt>
  <dd>grab a list of servers and names from another task and add them to current SERVERS list. Run retry to activate the connections. At startup an entry for this session with name `servers is added to the SERVERS table to simplify this.</dd>
  <dt>.servers.init[]</dt>
  <dd>(re)initialise the SERVERS table - doesn't close the connections, just loses track of them..</dd>
  <dt>.servers.loadcsv[file]</dt>
  <dd>load a list of servers from file (usually created by savecsv)</dd>
  <dt>names:.servers.names[]</dt>
  <dd>return a list of all available server names</dd>
  <dt>.servers.onlyone[]</dt>
  <dd>clean up the server list so that there is only one instance for each name+hpup combination, handles for duplicates are properly closed and removed</dd>
  <dt>.servers.reset[]</dt>
  <dd>same as init</dd>
  <dt>.servers.retry[]</dt>
  <dd>retry connecting to all servers in SERVERS which are currently down</dd>
  <dt>.servers.self[]</dt>
  <dd>list all servers which point to this session (useful if the list is to be shared with <grab>)</dd>
  <dt>.servers.up[]</dt>
  <dd>list all servers which are currently up</dd>
<dt>.servers.savecsv[file]</dt>
<dd>save a list of all servers to file</dd>
</dl>
<h4>sample session:</h4>
<code>q)\l trackservers.q<br />
q).servers.add[`sss;`:5001]<br />
816<br />
q).servers.add[`sss;`:5001]<br />
804<br />
q)show SERVERS<br />
name hpup&nbsp; w&nbsp;&nbsp; private<br />
----------------------<br />
sss&nbsp; :5001 816 0<br />
sss&nbsp; :5001 804 0<br />
q).servers.handlefor`sss<br />
804<br />
q).servers.all[]<br />
`s#,`sss<br />
q)</code><br />
<p>undo/remove the tracking by running .usage.revert[].</p>
<h2>access control</h2>
<h3>controlaccess.q</h3>
<p>this is just a sample from the vast number  of ways you could control access. It restricts access by remote hostname pattern ("server*.foo.com" etc), then by user and within user by accesstypes similiar to vanilla XP style. Users are either default users who can only call canned commands (VALIDCMDSYMBOLS); powerusers who can do all a defaultuser can and execute a restricted selection of queries; or superusers who can do anything.</p>
<p>invalid access attempts are logged to file .access.FILE, display it with loadinvalidaccess.q</p>
<h3>controlaccess.custom.q</h3>
<p>customise the checks here, so controlaccess.q doesn't have to be changed.</p>
<h4>customisable functions and variables:</h4>
<dl>
  <dt>.access.VALIDHOSTPATTERNS</dt>
  <dd>a list of hostname patterns the .Q.host .z.a is checked against, for example "server[01]?.foo.com"</dd>
  <dt>.access.VALIDCMDPATTERNS</dt>
  <dd>a list of q patterns the input is validated against, for example "select*".</dd>
  <dt>.access.VALIDCMDSYMBOLS</dt>
  <dd>a list of symbols for canned functions that can be called, for example `report00`report01</dd>
  <dt>.access.STOPWORDS</dt>
  <dd>words which can't appear in a poweruser's queries, example words are `system and `exit</dd>
  <dt>.access.USERS</dt>
  <dd>(.z.u) users together with their access level</dd>
  <dt>.access.addsuperuser|addpoweruser|adddefaultuser[user]</dt>
  <dd>add a user to the valid users table</dd>
   <dt>.access.deleteusers[users]</dt>
  <dd>delete users from the valid users table. Add and delete users has immediate effect</dd>

</dl>
<h3>loadinvalidaccess.q</h3>
<p>load and display the list of invalid access attempts from the
logfile.</p>
<h4>sample output:</h4>
<code>S:\&gt;q loadinvalidaccess.q<br />
KDB+ 2.3t 2005.11.08 Copyright (C) 1993-2005 Kx Systems<br />
date time zcmd ipa u w cmd<br />
--------------------------------------------------------<br />
2005.10.29 16:42:54.734 pi 127.0.0.1 qcon 828 2+22 33<br />
2005.10.29 16:42:55.969 pi 127.0.0.1 qcon 828<br />
2005.10.29 16:42:56.750 pi 127.0.0.1 qcon 828<br />
2005.10.29 16:42:57.172 pi 127.0.0.1 qcon 828<br />
2005.10.29 16:42:57.484 pi 127.0.0.1 qcon 828<br />
2005.11.02 16:41:14.312 pg 127.0.0.1 simon 836 2+2<br />
q) </code>
<h2>running tasks remotely</h2>
<h3>remotetasks.q</h3>
<p>this is like the hgf futures from the handle-gateway code - but standalone. Loading the code into a client (and ideally combining with trackservers.q) you can submit asynchronous requests to other servers and get them to post the results back into a table in your client workspace.</p>
<p>when a piece of code is submitted to a server (handle) a request id is returned which can be used to check for results and status. Optionally requests can be grouped with an id (grp) to simplify checking on the status of a gaggle of code</p>
<h4>api:</h4>
<dl>
  <dt>requests:.tasks.nrs[]</dt>
  <dd>return all request numbers</dd>
  <dt>requests:.tasks.cancelled[]</dt>
  <dd>return all cancelled request numbers</dd>
  <dt>requests:.tasks.chase[requests]</dt>
  <dd>chase&nbsp;requests by submitting a dummy synch request over each handle used - when this returns you can be sure all requests have completed</dd>
  <dt>.tasks.clean[]</dt>
  <dd>clean up expired requests (see .tasks.RETAIN and
.tasks.AUTOCLEAN)</dd>
  <dt>requests:.tasks.completed[]</dt>
  <dd>return all successfully completed request numbers</dd>
  <dt>requests:.tasks.failed[]</dt>
  <dd>return all failed request numbers</dd>
  <dt>requests:.tasks.flush[requests]</dt>
  <dd>flush the&nbsp;queues for requests by closing the associated&nbsp;handles </dd>
  <dt>requests:.tasks.grp[grp]</dt>
  <dd>return the requests in a particular group </dd>
  <dt>ms:.tasks.ms[requests]</dt>
  <dd>return the milliseconds taken to execute requests</dd>
  <dt>requests:.tasks.pending[]</dt>
  <dd>return&nbsp;all pending request numbers</dd>
  <dt>.tasks.reset[]</dt>
  <dd>resets (empties) the TASKS directory</dd>
  <dt>results:.tasks.results[requests]</dt>
  <dd>return the results for the completed requests in
&lt;requests&gt;</dd>
  <dt>.tasks.resultsf[requests]</dt>
  <dd>like &lt;results&gt; except that it forces all requests to be completed&nbsp;</dd>
  <dt>status:.tasks.status[requests]</dt>
  <dd>return the status of each of requests </dd>
  <dt>request:.tasks.submit[handle;expr]</dt>
  <dd>return the request number for executing &lt;expr&gt; in the server connected to &lt;handle&gt;</dd>
  <dt>request:.tasks.submitg[handle;grp;expr]</dt>
  <dd>like &lt;submit&gt; except that you can supply the grp (use .taskgrps.next[] to obtain one) if you want to manually group
requests</dd>
  <dt>grps:.taskgrps.grps[]</dt>
  <dd>return all group numbers</dd>
  <dt>requests:.taskgrps.nrs[grps]</dt>
  <dd>return all the request numbers in grps</dd>
  <dt>grp:.taskgrps.nextgrp[]</dt>
  <dd>return the &nbsp;next available group number</dd>
  <dt>requests:.taskgrps.grp[grp;requests]</dt>
  <dd>group a collection of requests into group
&lt;grp&gt;</dd>
</dl>
<h4>sample output:</h4>
<code>q)\l remotetasks.q<br />
q)h:hopen`:5001<br />
q).tasks.submit[h;"key 3"]<br />
1<br />
q).tasks.submit[h;"key 5"]<br />
2<br />
q).tasks.resultsf .tasks.chase 1 2<br />
1 2!(0 1 2;0 1 2 3 4)<br />
q)show .tasks.resultsf .tasks.chase 1 2<br />
1| 0 1 2<br />
2| 0 1 2 3 4<br />
q)show .tasks.resultsf .tasks.chase 1 2 99<br />
'tasks<br />
q)show .tasks.status 1 2<br />
1| complete<br />
2| complete<br />
q)<br />
</code>
<h2>utilities</h2>
<h3>hutil.q</h3>
<p>miscellaneous handle utilities</p>
<dl>
<dt>hhostport[]</dt>
<dd>return this tasks's `:host:port</dd>
  <dt>hwhois[handle]</dt>
  <dd>ask handle for more information (k version, os etc)
    </dd>
  <dt>hhere[]</dt>
  <dd>like hwhois, but for current task 
    </dd>
  <dt>hvalid[handle]</dt>
  <dd>check if handle is a valid connection</dd>
  <dt>hkill[handle]</dt>
  <dd>kill the task at the other end of the handle connection</dd>
  <dt>hdsx0/hdsx/hx0/hx[handles;qcode]</dt>
  <dd>utilities to run qcode in tasks connected to handles and return the results in a simple table, ..x0 versions are not error trapped, the ..x versions are. This is a remotetasks.q-lite.</dd>
</dl>
</div>
<div id="footer">
<p> 2006-08-29 | <a href="#top" title="return to top of this page">top</a> </p>
</div>
</div>
</body>
</html>
